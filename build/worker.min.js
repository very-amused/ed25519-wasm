/**
 * @license
 * ed25519-wasm v0.1.2
 * MIT License
 * Copyright (c) 2022 Keith Scroggs
 */
class e{constructor(e){this.worker=e,this.worker.addEventListener("message",(e=>{this.onMessage(e)}),!0)}onMessage(e){this.resolve&&this.resolve(e.data)}postMessage(e,r=[]){const s=new Promise((e=>{this.resolve=e}));return this.worker.postMessage(e,r),s}deinit(){this.worker.removeEventListener("message",(e=>{this.onMessage(e)}),!0),this.worker.terminate()}}var r;let s;function t(e){return e instanceof Error?e.message:"string"==typeof e?e:"An unknown error has occured, and a message was unable to be parsed from this error"}function n(e){"number"==typeof e&&e in r.ErrorCodes?o({code:e}):o({code:r.ErrorCodes.Unknown,message:t(e)})}!function(r){var s,t;r.WorkerConnection=e,r.seedLen=32,r.publicKeyLen=32,r.privateKeyLen=64,r.signatureLen=64,(s=r.Methods||(r.Methods={}))[s.LoadED25519=0]="LoadED25519",s[s.GenerateKeypair=1]="GenerateKeypair",s[s.SignMessage=2]="SignMessage",(t=r.ErrorCodes||(r.ErrorCodes={}))[t.Success=0]="Success",t[t.BadRequest=1]="BadRequest",t[t.UnsupportedBrowser=2]="UnsupportedBrowser",t[t.Unknown=3]="Unknown"}(r||(r={}));const o=(e,r=[])=>{self.postMessage(e,r)};function a(e,r){for(let s=0;s<r.length;s++)e[s]=r[s]}function i(e,r=1){for(let s=0;s<r;s++)for(let r=0;r<e.length;r++)e[r]=0}onmessage=async function(e){const t=e.data;switch(t.method){case r.Methods.LoadED25519:try{const e=t.params;s=await async function(e="."){if("object"!=typeof WebAssembly)throw r.ErrorCodes.UnsupportedBrowser;let s;if("function"==typeof WebAssembly.instantiateStreaming)s=await WebAssembly.instantiateStreaming(fetch(e));else{const r=await fetch(e),t=await r.arrayBuffer();s=await WebAssembly.instantiate(t)}return s.instance.exports}(e.wasmPath),o({code:r.ErrorCodes.Success})}catch(e){n(e)}break;case r.Methods.GenerateKeypair:try{const e=t.params,n=await async function(e,t=!0){const{seedLen:n,publicKeyLen:o,privateKeyLen:c}=r,f=s.malloc(n),u=new Uint8Array(s.memory.buffer,f,n);a(u,e);const d=s.malloc(o),y=s.malloc(c);s.ed25519_keypair(f,d,y),i(u),s.free(f);const l=new Uint8Array(s.memory.buffer,y,c),m=new Uint8Array(c);a(m,l);let b=null;const w=new Uint8Array(s.memory.buffer,d,o);return t||(b=new Uint8Array(o),a(b,w)),i(w),s.free(d),i(l),s.free(y),{body:{publicKey:b,privateKey:m},transfer:null!==b?[b.buffer,m.buffer]:[m.buffer]}}(e.seed,e.omitPublicKey);o({code:r.ErrorCodes.Success,body:n.body},n.transfer)}catch(e){n(e)}break;case r.Methods.SignMessage:try{const e=t.params,n=await async function(e,t){const{privateKeyLen:n,signatureLen:o}=r,c=e.length,f=s.malloc(c),u=new Uint8Array(s.memory.buffer,f,c);a(u,e);const d=s.malloc(n),y=new Uint8Array(s.memory.buffer,d,n);a(y,t);const l=s.malloc(o+c);s.ed25519_sign(l,f,c,d),i(u),s.free(f),i(y),s.free(d);const m=new Uint8Array(s.memory.buffer,l,o+c),b=new Uint8Array(o);return a(b,m.slice(0,64)),i(m),s.free(l),b}(e.message,e.privateKey);o({code:r.ErrorCodes.Success,body:{signature:n}},[n.buffer])}catch(e){n(e)}break;default:o({code:r.ErrorCodes.BadRequest})}};
