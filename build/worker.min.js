class e{constructor(e){this.worker=e,this.worker.addEventListener("message",(e=>{this.onMessage(e)}),!0)}onMessage(e){this.resolve&&this.resolve(e.data)}postMessage(e,r=[]){const s=new Promise((e=>{this.resolve=e}));return this.worker.postMessage(e,r),s}deinit(){this.worker.removeEventListener("message",(e=>{this.onMessage(e)}),!0),this.worker.terminate()}}var r;let s;function t(e){return e instanceof Error?e.message:"string"==typeof e?e:"An unknown error has occured, and a message was unable to be parsed from this error"}function n(e){"number"==typeof e&&e in r.ErrorCodes?o({code:e}):o({code:r.ErrorCodes.Unknown,message:t(e)})}!function(r){var s,t;r.WorkerConnection=e,r.seedLen=32,r.publicKeyLen=32,r.privateKeyLen=64,(s=r.Methods||(r.Methods={}))[s.LoadED25519=0]="LoadED25519",s[s.GenerateKeypair=1]="GenerateKeypair",(t=r.ErrorCodes||(r.ErrorCodes={}))[t.Success=0]="Success",t[t.BadRequest=1]="BadRequest",t[t.UnsupportedBrowser=2]="UnsupportedBrowser",t[t.Unknown=3]="Unknown"}(r||(r={}));const o=(e,r=[])=>{self.postMessage(e,r)};function a(e,r){for(let s=0;s<r.length;s++)e[s]=r[s]}function i(e,r=1){for(let s=0;s<r;s++)for(let r=0;r<e.length;r++)e[r]=0}onmessage=async function(e){const t=e.data;switch(t.method){case r.Methods.LoadED25519:try{const e=t.params;s=await async function(e="."){if("object"!=typeof WebAssembly)throw r.ErrorCodes.UnsupportedBrowser;let s;if("function"==typeof WebAssembly.instantiateStreaming)s=await WebAssembly.instantiateStreaming(fetch(e));else{const r=await fetch(e),t=await r.arrayBuffer();s=await WebAssembly.instantiate(t)}return s.instance.exports}(e.wasmPath),o({code:r.ErrorCodes.Success})}catch(e){n(e)}break;case r.Methods.GenerateKeypair:try{const e=t.params,n=await async function(e,t=!0){const{seedLen:n,publicKeyLen:o,privateKeyLen:c}=r,d=s.malloc(n),f=new Uint8Array(s.memory.buffer,d,n);a(f,e);const u=s.malloc(o),y=s.malloc(c);s.ed25519_keypair(d,u,y),i(f),s.free(d);const l=new Uint8Array(s.memory.buffer,y,c),m=new Uint8Array(c);a(m,l);let w=null;const b=new Uint8Array(s.memory.buffer,u,o);return t||(w=new Uint8Array(o),a(w,b)),i(b),s.free(u),i(l),s.free(y),{body:{publicKey:w,privateKey:m},transfer:null!==w?[w.buffer,m.buffer]:[m.buffer]}}(e.seed,e.omitPublicKey);o({code:r.ErrorCodes.Success,body:n.body},n.transfer)}catch(e){n(e)}break;default:o({code:r.ErrorCodes.BadRequest})}};
